<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Python语言规范 | 日常幻想指南</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="谦虚 谨慎 严肃 活泼">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Python语言规范 | 日常幻想指南">
    <meta name="twitter:description" content="谦虚 谨慎 严肃 活泼">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Python语言规范 | 日常幻想指南">
    <meta property="og:description" content="谦虚 谨慎 严肃 活泼">

    
    <meta name="author" content="陈不帅">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="日常幻想指南" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2017/12/26/Python语言规范/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 日常幻想指南 的主页"><img src="/images/logo.jpg" width="80" alt="日常幻想指南 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 日常幻想指南">日常幻想指南</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">谦虚 谨慎 严肃 活泼</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/favourite">魔法工坊</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/csZzZz" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="Twitter" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-12-25T23:14:04.000Z" class="post-list__meta--date date">2017-12-26</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/Python/">Python</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Python语言规范</h1>
  </header>

  <section class="post">
    <h3 id="搬运自Python语言规范"><a href="#搬运自Python语言规范" class="headerlink" title="搬运自Python语言规范"></a>搬运自<a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="external">Python语言规范</a></h3><h3 id="1-对你的代码运行pylint"><a href="#1-对你的代码运行pylint" class="headerlink" title="1.对你的代码运行pylint"></a>1.对你的代码运行pylint</h3><hr>
<p><strong>定义:</strong><br>    pylint是一个在Python源代码中查找bug的工具. 对于C和C++这样的不那么动态的(译者注: 原文是less dynamic)语言, 这些bug通常由编译器来捕获. 由于Python的动态特性, 有些警告可能不对. 不过伪告警应该很少.</p>
<p><strong>优点:</strong><br>    可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等.</p>
<p><strong>缺点:</strong><br>    pylint不完美. 要利用其优势, 我们有时侯需要: a) 围绕着它来写代码 b) 抑制其告警 c) 改进它, 或者d) 忽略它.</p>
<p><strong>结论:</strong><br>    确保对你的代码运行pylint.抑制不准确的警告,以便能够将其他警告暴露出来。</p>
<h3 id="2-导入–仅对包和模块使用导入"><a href="#2-导入–仅对包和模块使用导入" class="headerlink" title="2.导入–仅对包和模块使用导入"></a>2.导入–仅对包和模块使用导入</h3><hr>
<p><strong>定义:</strong><br>    模块间共享代码的重用机制.</p>
<p><strong>优点:</strong><br>    命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. x.Obj表示Obj对象定义在模块x中.</p>
<p><strong>缺点:</strong><br>    模块名仍可能冲突. 有些模块名太长, 不太方便.</p>
<p>结论:<br>    使用 <code>import x</code> 来导入包和模块. </p>
<p>   使用 <code>from x import y</code> , 其中x是包前缀, y是不带前缀的模块名.</p>
<p>   使用 <code>from x import y as z</code>, 如果两个要导入的模块都叫做y或者y太长了.</p>
<p>   例如, 模块 <code>sound.effects.echo</code> 可以用如下方式导入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div><div class="line">...</div><div class="line">echo.EchoFilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</div></pre></td></tr></table></figure></p>
<p>   导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次. </p>
<h3 id="3-使用模块的全路径名来导入每个模块"><a href="#3-使用模块的全路径名来导入每个模块" class="headerlink" title="3.使用模块的全路径名来导入每个模块"></a>3.使用模块的全路径名来导入每个模块</h3><hr>
<p><strong>优点:</strong><br>    避免模块名冲突. 查找包更容易. </p>
<p><strong>缺点:</strong><br>    部署代码变难, 因为你必须复制包层次. </p>
<p><strong>结论:</strong><br>    所有的新代码都应该用完整包名来导入每个模块.应该像下面这样导入:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Reference in code with complete name.</span></div><div class="line"><span class="keyword">import</span> sound.effects.echo</div><div class="line"></div><div class="line"><span class="comment"># Reference in code with just module name (preferred).</span></div><div class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</div></pre></td></tr></table></figure>
<h3 id="4-允许使用异常-但必须小心"><a href="#4-允许使用异常-但必须小心" class="headerlink" title="4.允许使用异常, 但必须小心"></a>4.允许使用异常, 但必须小心</h3><hr>
<p><strong>定义:</strong><br>    异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式. </p>
<p><strong>优点:</strong><br>    正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码. </p>
<p><strong>缺点:</strong><br>    可能会导致让人困惑的控制流. 调用库时容易错过错误情况. </p>
<p><strong>结论:</strong><br>    异常必须遵守特定条件:</p>
<ol>
<li><p>像这样触发异常: <code>raise MyException(&quot;Error message&quot;)</code> 或者 <code>raise MyException</code> . 不要使用两个参数的形式( <code>raise MyException, &quot;Error message&quot;</code> )或者过时的字符串异常( <code>raise &quot;Error message&quot;</code> ).<br>模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做”Error”.</p>
</li>
<li><p>永远不要使用 <code>except:</code> 语句来捕获所有异常, 也不要捕获 <code>Exception</code> 或者 <code>StandardError</code> , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, <code>except:</code> 真的会捕获包括Python语法错误在内的任何错误. 使用 <code>except:</code> 很容易隐藏真正的bug. </p>
</li>
<li><p>尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误. </p>
</li>
<li>使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</li>
<li>当捕获异常时, 使用 <code>as</code> 而不要用逗号. 例如:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">raise</span> Error</div><div class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-避免全局变量"><a href="#5-避免全局变量" class="headerlink" title="5.避免全局变量"></a>5.避免全局变量</h3><hr>
<p><strong>定义:</strong><br>    定义在模块级的变量.</p>
<p><strong>优点:</strong><br>    偶尔有用. </p>
<p><strong>缺点:</strong><br>    导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值. </p>
<p><strong>结论:</strong><br>    避免使用全局变量, 用类变量来代替. 但也有一些例外:</p>
<p>   #. 脚本的默认选项.</p>
<pre><code>#. 模块级常量. 例如:　PI = 3.14159. 常量应该全大写, 用下划线连接. 
#. 有时候用全局变量来缓存值或者作为函数返回值很有用. 
#. 如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问. 
</code></pre><h3 id="6-鼓励使用嵌套-本地-内部类或函数"><a href="#6-鼓励使用嵌套-本地-内部类或函数" class="headerlink" title="6.鼓励使用嵌套/本地/内部类或函数"></a>6.鼓励使用嵌套/本地/内部类或函数</h3><hr>
<p><strong>定义:</strong><br>    类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的. </p>
<p><strong>优点:</strong><br>    允许定义仅用于有效范围的工具类和函数. </p>
<p><strong>缺点:</strong><br>    嵌套类或局部类的实例不能序列化(pickled).</p>
<p><strong>结论:</strong><br>    推荐使用.</p>
<h3 id="7-可以在简单情况下使用列表推导-List-Comprehensions"><a href="#7-可以在简单情况下使用列表推导-List-Comprehensions" class="headerlink" title="7.可以在简单情况下使用列表推导(List Comprehensions)"></a>7.可以在简单情况下使用列表推导(List Comprehensions)</h3><hr>
<p><strong>定义:</strong><br>    列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助map(), filter(), 或者lambda.</p>
<p><strong>优点:</strong><br>    简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表. </p>
<p><strong>缺点:</strong><br>    复杂的列表推导或者生成器表达式可能难以阅读. </p>
<p><strong>结论:</strong><br>    适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环.</p>
<h3 id="8-默认迭代器和操作符"><a href="#8-默认迭代器和操作符" class="headerlink" title="8.默认迭代器和操作符"></a>8.默认迭代器和操作符</h3><hr>
<pre><code>如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等.
</code></pre><p><strong>定义:</strong><br>    容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(in和not in)</p>
<p><strong>优点:</strong><br>    默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型. </p>
<p><strong>缺点:</strong><br>    你没法通过阅读方法名来区分对象的类型(例如, has_key()意味着字典). 不过这也是优点. </p>
<p><strong>结论:</strong><br>    如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Yes:  </div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</div><div class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</div><div class="line"><span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dict.iteritems(): ...</div><div class="line"> </div><div class="line">.. code-block:: python </div><div class="line">    </div><div class="line">No:   </div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> adict.keys(): ...</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> adict.has_key(key): ...</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> afile.readlines(): ...</div></pre></td></tr></table></figure>
<h3 id="9-生成器–按需使用生成器"><a href="#9-生成器–按需使用生成器" class="headerlink" title="9.生成器–按需使用生成器."></a>9.生成器–按需使用生成器.</h3><hr>
<p><strong>定义:</strong><br>    所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成. </p>
<p><strong>优点:</strong><br>    简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少. </p>
<p><strong>缺点:</strong><br>    没有.</p>
<p><strong>结论:</strong><br>    鼓励使用. 注意在生成器函数的文档字符串中使用”Yields:”而不是”Returns:”.</p>
<h3 id="10-Lambda函数–适用于单行函数"><a href="#10-Lambda函数–适用于单行函数" class="headerlink" title="10.Lambda函数–适用于单行函数"></a>10.Lambda函数–适用于单行函数</h3><hr>
<p><strong>定义:</strong><br>    与语句相反, lambda在一个表达式中定义匿名函数. 常用于为 <code>map()</code> 和 <code>filter()</code> 之类的高阶函数定义回调函数或者操作符.</p>
<p><strong>优点:</strong><br>    方便.</p>
<p><strong>缺点:</strong><br>    比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于lambda函数通常只包含一个表达式, 因此其表达能力有限. </p>
<p><strong>结论:</strong><br>    适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数.</p>
<pre><code>对于常见的操作符，例如乘法操作符，使用 ``operator`` 模块中的函数以代替lambda函数. 例如, 推荐使用 ``operator.mul`` , 而不是 ``lambda x, y: x * y`` . 
</code></pre><h3 id="11-条件表达式"><a href="#11-条件表达式" class="headerlink" title="11.条件表达式"></a>11.条件表达式</h3><hr>
<pre><code>适用于单行函数
</code></pre><p><strong>定义:</strong><br>    条件表达式是对于if语句的一种更为简短的句法规则. 例如: <code>x = 1 if cond else 2</code> .</p>
<p><strong>优点:</strong><br>    比if语句更加简短和方便.</p>
<p><strong>缺点:</strong><br>    比if语句难于阅读. 如果表达式很长， 难于定位条件. </p>
<p><strong>结论:</strong><br>    适用于单行函数. 在其他情况下，推荐使用完整的if语句.    </p>
<h3 id="12-默认参数值"><a href="#12-默认参数值" class="headerlink" title="12.默认参数值"></a>12.默认参数值</h3><hr>
<pre><code>适用于大部分情况.
</code></pre><p><strong>定义:</strong><br>    你可以在函数参数列表的最后指定变量的值, 例如, <code>def foo(a, b = 0):</code> . 如果调用foo时只带一个参数, 则b被设为0. 如果带两个参数, 则b的值等于第二个参数. </p>
<p><strong>优点:</strong><br>    你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python也不支持重载方法和函数, 默认参数是一种”仿造”重载行为的简单方式. </p>
<p><strong>缺点:</strong><br>    默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了. </p>
<p><strong>结论:</strong><br>    鼓励使用, 不过有如下注意事项:</p>
<pre><code>不要在函数或方法定义中使用可变对象作为默认值.        
</code></pre><h3 id="13-属性-properties"><a href="#13-属性-properties" class="headerlink" title="13.属性(properties)"></a>13.属性(properties)</h3><hr>
<pre><code>访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们.    
</code></pre><p><strong>定义:</strong><br>    一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式. </p>
<p><strong>优点:</strong><br>    通过消除简单的属性(attribute)访问时显式的get和set方法调用, 可读性提高了. 允许懒惰的计算. 用Pythonic的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上. </p>
<p><strong>缺点:</strong><br>    属性(properties)是在get和set方法声明后指定, 这需要使用者在接下来的代码中注意: set和get是用于属性(properties)的(除了用 <code>@property</code> 装饰器创建的只读属性).  必须继承自object类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑. </p>
<p><strong>结论:</strong><br>    你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用 <code>@property</code> <a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Function_and_Method_Decorators" target="_blank" rel="external">装饰器</a>_ 来创建.</p>
<p>  如果子类没有覆盖属性, 那么属性的继承可能看上去不明显. 因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式).    </p>
<h3 id="14-True-False的求值"><a href="#14-True-False的求值" class="headerlink" title="14.True/False的求值"></a>14.True/False的求值</h3><hr>
<pre><code>尽可能使用隐式false
</code></pre><p>定义:<br>    Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的”空”值都被认为是false. 因此0， None, [], {}, “” 都被认为是false.</p>
<p>优点:<br>    使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快. </p>
<p>缺点:<br>    对C/C++开发人员来说, 可能看起来有点怪. </p>
<p>结论:<br>    尽可能使用隐式的false, 例如: 使用 <code>if foo:</code> 而不是 <code>if foo != []:</code> . 不过还是有一些注意事项需要你铭记在心:</p>
<p>1.永远不要用==或者!=来比较单件, 比如None. 使用is或者is not.</p>
<ol>
<li>注意: 当你写下 <code>if x:</code> 时, 你其实表示的是 <code>if x is not None</code> . 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!</li>
<li>永远不要用==将一个布尔量与false相比较. 使用 <code>if not x:</code> 代替. 如果你需要区分false和None, 你应该用像 <code>if not x and x is not None:</code> 这样的语句.</li>
<li>对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此 <code>if not seq:</code> 或者 <code>if seq:</code> 比 <code>if len(seq):</code> 或 <code>if not len(seq):</code> 要更好.</li>
<li>处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Yes: </div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> users:</div><div class="line">	<span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line"><span class="keyword">if</span> foo == <span class="number">0</span>:</div><div class="line">	self.handle_zero()</div><div class="line"></div><div class="line"><span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</div><div class="line">	self.handle_multiple_of_ten()    </div><div class="line">	                   </div><div class="line">No:</div><div class="line"><span class="keyword">if</span> len(users) == <span class="number">0</span>:</div><div class="line">	<span class="keyword">print</span> <span class="string">'no users'</span></div><div class="line">	</div><div class="line"><span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foo:</div><div class="line">	self.handle_zero()</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">10</span>:</div><div class="line">	self.handle_multiple_of_ten()  </div><div class="line">                     </div><div class="line"><span class="comment">#. 注意'0'(字符串)会被当做true.</span></div></pre></td></tr></table></figure>
<h3 id="15-过时的语言特性"><a href="#15-过时的语言特性" class="headerlink" title="15.过时的语言特性"></a>15.过时的语言特性</h3><hr>
<p>尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for循环取代filter(), map()以及reduce().    </p>
<p>定义:<br>    当前版本的Python提供了大家通常更喜欢的替代品. </p>
<p>结论:<br>    我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式.</p>
<h3 id="16-词法作用域-Lexical-Scoping"><a href="#16-词法作用域-Lexical-Scoping" class="headerlink" title="16.词法作用域(Lexical Scoping)"></a>16.词法作用域(Lexical Scoping)</h3><hr>
<p><strong>推荐使用</strong></p>
<p>定义:<br>    嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量. </p>
<p>一个使用这个特性的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_adder</span><span class="params">(summand1)</span>:</span></div><div class="line"><span class="string">"""Returns a function that adds numbers to a given number."""</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(summand2)</span>:</span></div><div class="line">		<span class="keyword">return</span> summand1 + summand2</div><div class="line">	<span class="keyword">return</span> adder</div></pre></td></tr></table></figure>
<p>优点:<br>    通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰. </p>
<p>缺点:<br>    可能导致让人迷惑的bug. 例如下面这个依据<a href="http://www.python.org/dev/peps/pep-0227/" target="_blank" rel="external"></a>的例子:</p>
<pre><code class="python">i = <span class="number">4</span>
<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>
        <span class="keyword">print</span> i,

    <span class="keyword">for</span> i <span class="keyword">in</span> x:  <span class="comment"># Ah, i *is* local to Foo, so this is what Bar sees</span>
       <span class="keyword">print</span> i,bar()
</code></pre>
<p>因此 <code>foo([1, 2, 3])</code> 会打印 <code>1 2 3 3</code> , 不是 <code>1 2 3 4</code> .<br>结论:<br>    鼓励使用. </p>
<h3 id="17-函数与方法装饰器"><a href="#17-函数与方法装饰器" class="headerlink" title="17.函数与方法装饰器"></a>17.函数与方法装饰器</h3><hr>
<pre><code>如果好处很显然, 就明智而谨慎的使用装饰器  
</code></pre><p>定义:<br>    <a href="https://docs.python.org/release/2.4.3/whatsnew/node6.html" target="_blank" rel="external">用于函数及方法的装饰器</a><br>    最常见的装饰器是@classmethod 和@staticmethod, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器.<br>优点:<br>    优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等.</p>
<p>缺点:<br>    装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能.</p>
<p>结论:<br>    如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试.<br>    避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(由 <code>pydoc</code> 或其它工具导入). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的.<br>    装饰器是一种特殊形式的”顶级代码”. 参考后面关于 :ref:<code>Main &lt;main&gt;</code> 的话题. </p>
<h3 id="18-线程"><a href="#18-线程" class="headerlink" title="18.线程"></a>18.线程</h3><hr>
<pre><code>不要依赖内建类型的原子性.
</code></pre><p>虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果<strong>hash</strong>或<strong>eq</strong>被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).</p>
<p>优先使用Queue模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用 <code>threading.Condition</code> 来取代低级别的锁了. </p>
<h3 id="19-威力过大的特性"><a href="#19-威力过大的特性" class="headerlink" title="19.威力过大的特性"></a>19.威力过大的特性</h3><hr>
<pre><code>避免使用这些特性    
</code></pre><p>定义:<br>    Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等.</p>
<p>优点:<br>    强大的语言特性, 能让你的代码更紧凑.</p>
<p>缺点:<br>    使用这些很”酷”的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解. </p>
<p>结论:<br>    在你的代码中避免这些特性.     </p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/12/26/Python风格规范/" title="Python风格规范">Python风格规范</a></h2>
                <p class="excerpt">
                
                MARK一下，随时翻看，就不搬运了
Python风格规范Github地址
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-12-25T23:58:26.000Z" class="post-list__meta--date date">2017-12-26</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/Python/">Python</a>
</span><a class="btn-border-small" href="/2017/12/26/Python风格规范/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/12/25/Linux命令之系统信息/" title="Linux命令之系统信息">Linux命令之系统信息</a></h2>
                <p class="excerpt">
                
                日期和时间


命令
含义




date
系统时间


cal
calendar 查看日历，-y 选项可以查看一年的日历



磁盘信息


命令
含义




df -h
disk free 显示磁盘剩余空间


du -h[目录名]
disk usage 显示目录下的文件大小


选项说明 
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-12-24T22:59:04.000Z" class="post-list__meta--date date">2017-12-25</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/Linux/">Linux</a>
</span><a class="btn-border-small" href="/2017/12/25/Linux命令之系统信息/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 陈不帅 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
